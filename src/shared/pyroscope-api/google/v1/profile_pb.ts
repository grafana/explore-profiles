// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Profile is a common stacktrace profile format.
//
// Measurements represented with this format should follow the
// following conventions:
//
// - Consumers should treat unset optional fields as if they had been
//   set with their default value.
//
// - When possible, measurements should be stored in "unsampled" form
//   that is most useful to humans.  There should be enough
//   information present to determine the original sampled values.
//
// - On-disk, the serialized proto must be gzip-compressed.
//
// - The profile is represented as a set of samples, where each sample
//   references a sequence of locations, and where each location belongs
//   to a mapping.
// - There is a N->1 relationship from sample.location_id entries to
//   locations. For every sample.location_id entry there must be a
//   unique Location with that id.
// - There is an optional N->1 relationship from locations to
//   mappings. For every nonzero Location.mapping_id there must be a
//   unique Mapping with that id.

// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file google/v1/profile.proto (package google.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/v1/profile.proto.
 */
export const file_google_v1_profile: GenFile = /*@__PURE__*/
  fileDesc("Chdnb29nbGUvdjEvcHJvZmlsZS5wcm90bxIJZ29vZ2xlLnYxIp8DCgdQcm9maWxlEikKC3NhbXBsZV90eXBlGAEgAygLMhQuZ29vZ2xlLnYxLlZhbHVlVHlwZRIhCgZzYW1wbGUYAiADKAsyES5nb29nbGUudjEuU2FtcGxlEiMKB21hcHBpbmcYAyADKAsyEi5nb29nbGUudjEuTWFwcGluZxIlCghsb2NhdGlvbhgEIAMoCzITLmdvb2dsZS52MS5Mb2NhdGlvbhIlCghmdW5jdGlvbhgFIAMoCzITLmdvb2dsZS52MS5GdW5jdGlvbhIUCgxzdHJpbmdfdGFibGUYBiADKAkSEwoLZHJvcF9mcmFtZXMYByABKAMSEwoLa2VlcF9mcmFtZXMYCCABKAMSEgoKdGltZV9uYW5vcxgJIAEoAxIWCg5kdXJhdGlvbl9uYW5vcxgKIAEoAxIpCgtwZXJpb2RfdHlwZRgLIAEoCzIULmdvb2dsZS52MS5WYWx1ZVR5cGUSDgoGcGVyaW9kGAwgASgDEg8KB2NvbW1lbnQYDSADKAMSGwoTZGVmYXVsdF9zYW1wbGVfdHlwZRgOIAEoAyInCglWYWx1ZVR5cGUSDAoEdHlwZRgBIAEoAxIMCgR1bml0GAIgASgDIk0KBlNhbXBsZRITCgtsb2NhdGlvbl9pZBgBIAMoBBINCgV2YWx1ZRgCIAMoAxIfCgVsYWJlbBgDIAMoCzIQLmdvb2dsZS52MS5MYWJlbCJACgVMYWJlbBILCgNrZXkYASABKAMSCwoDc3RyGAIgASgDEgsKA251bRgDIAEoAxIQCghudW1fdW5pdBgEIAEoAyLdAQoHTWFwcGluZxIKCgJpZBgBIAEoBBIUCgxtZW1vcnlfc3RhcnQYAiABKAQSFAoMbWVtb3J5X2xpbWl0GAMgASgEEhMKC2ZpbGVfb2Zmc2V0GAQgASgEEhAKCGZpbGVuYW1lGAUgASgDEhAKCGJ1aWxkX2lkGAYgASgDEhUKDWhhc19mdW5jdGlvbnMYByABKAgSFQoNaGFzX2ZpbGVuYW1lcxgIIAEoCBIYChBoYXNfbGluZV9udW1iZXJzGAkgASgIEhkKEWhhc19pbmxpbmVfZnJhbWVzGAogASgIIm0KCExvY2F0aW9uEgoKAmlkGAEgASgEEhIKCm1hcHBpbmdfaWQYAiABKAQSDwoHYWRkcmVzcxgDIAEoBBIdCgRsaW5lGAQgAygLMg8uZ29vZ2xlLnYxLkxpbmUSEQoJaXNfZm9sZGVkGAUgASgIIikKBExpbmUSEwoLZnVuY3Rpb25faWQYASABKAQSDAoEbGluZRgCIAEoAyJfCghGdW5jdGlvbhIKCgJpZBgBIAEoBBIMCgRuYW1lGAIgASgDEhMKC3N5c3RlbV9uYW1lGAMgASgDEhAKCGZpbGVuYW1lGAQgASgDEhIKCnN0YXJ0X2xpbmUYBSABKANCLQodY29tLmdvb2dsZS5wZXJmdG9vbHMucHJvZmlsZXNCDFByb2ZpbGVQcm90b2IGcHJvdG8z");

/**
 * @generated from message google.v1.Profile
 */
export type Profile = Message<"google.v1.Profile"> & {
  /**
   * A description of the samples associated with each Sample.value.
   * For a cpu profile this might be:
   *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
   * For a heap profile, this might be:
   *   [["allocations","count"], ["space","bytes"]],
   * If one of the values represents the number of events represented
   * by the sample, by convention it should be at index 0 and use
   * sample_type.unit == "count".
   *
   * @generated from field: repeated google.v1.ValueType sample_type = 1;
   */
  sampleType: ValueType[];

  /**
   * The set of samples recorded in this profile.
   *
   * @generated from field: repeated google.v1.Sample sample = 2;
   */
  sample: Sample[];

  /**
   * Mapping from address ranges to the image/binary/library mapped
   * into that address range.  mapping[0] will be the main binary.
   *
   * @generated from field: repeated google.v1.Mapping mapping = 3;
   */
  mapping: Mapping[];

  /**
   * Useful program location
   *
   * @generated from field: repeated google.v1.Location location = 4;
   */
  location: Location[];

  /**
   * Functions referenced by locations
   *
   * @generated from field: repeated google.v1.Function function = 5;
   */
  function: Function[];

  /**
   * A common table for strings referenced by various messages.
   * string_table[0] must always be "".
   *
   * @generated from field: repeated string string_table = 6;
   */
  stringTable: string[];

  /**
   * frames with Function.function_name fully matching the following
   * regexp will be dropped from the samples, along with their successors.
   *
   * Index into string table.
   *
   * @generated from field: int64 drop_frames = 7;
   */
  dropFrames: bigint;

  /**
   * frames with Function.function_name fully matching the following
   * regexp will be kept, even if it matches drop_frames.
   *
   * Index into string table.
   *
   * @generated from field: int64 keep_frames = 8;
   */
  keepFrames: bigint;

  /**
   * Time of collection (UTC) represented as nanoseconds past the epoch.
   *
   * @generated from field: int64 time_nanos = 9;
   */
  timeNanos: bigint;

  /**
   * Duration of the profile, if a duration makes sense.
   *
   * @generated from field: int64 duration_nanos = 10;
   */
  durationNanos: bigint;

  /**
   * The kind of events between sampled ocurrences.
   * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
   *
   * @generated from field: google.v1.ValueType period_type = 11;
   */
  periodType?: ValueType;

  /**
   * The number of events between sampled occurrences.
   *
   * @generated from field: int64 period = 12;
   */
  period: bigint;

  /**
   * Freeform text associated to the profile.
   *
   * Indices into string table.
   *
   * @generated from field: repeated int64 comment = 13;
   */
  comment: bigint[];

  /**
   * Index into the string table of the type of the preferred sample
   * value. If unset, clients should default to the last sample value.
   *
   * @generated from field: int64 default_sample_type = 14;
   */
  defaultSampleType: bigint;
};

/**
 * Describes the message google.v1.Profile.
 * Use `create(ProfileSchema)` to create a new message.
 */
export const ProfileSchema: GenMessage<Profile> = /*@__PURE__*/
  messageDesc(file_google_v1_profile, 0);

/**
 * ValueType describes the semantics and measurement units of a value.
 *
 * @generated from message google.v1.ValueType
 */
export type ValueType = Message<"google.v1.ValueType"> & {
  /**
   * Index into string table.
   *
   * @generated from field: int64 type = 1;
   */
  type: bigint;

  /**
   * Index into string table.
   *
   * @generated from field: int64 unit = 2;
   */
  unit: bigint;
};

/**
 * Describes the message google.v1.ValueType.
 * Use `create(ValueTypeSchema)` to create a new message.
 */
export const ValueTypeSchema: GenMessage<ValueType> = /*@__PURE__*/
  messageDesc(file_google_v1_profile, 1);

/**
 * Each Sample records values encountered in some program
 * context. The program context is typically a stack trace, perhaps
 * augmented with auxiliary information like the thread-id, some
 * indicator of a higher level request being handled etc.
 *
 * @generated from message google.v1.Sample
 */
export type Sample = Message<"google.v1.Sample"> & {
  /**
   * The ids recorded here correspond to a Profile.location.id.
   * The leaf is at location_id[0].
   *
   * @generated from field: repeated uint64 location_id = 1;
   */
  locationId: bigint[];

  /**
   * The type and unit of each value is defined by the corresponding
   * entry in Profile.sample_type. All samples must have the same
   * number of values, the same as the length of Profile.sample_type.
   * When aggregating multiple samples into a single sample, the
   * result has a list of values that is the element-wise sum of the
   * lists of the originals.
   *
   * @generated from field: repeated int64 value = 2;
   */
  value: bigint[];

  /**
   * label includes additional context for this sample. It can include
   * things like a thread id, allocation size, etc
   *
   * @generated from field: repeated google.v1.Label label = 3;
   */
  label: Label[];
};

/**
 * Describes the message google.v1.Sample.
 * Use `create(SampleSchema)` to create a new message.
 */
export const SampleSchema: GenMessage<Sample> = /*@__PURE__*/
  messageDesc(file_google_v1_profile, 2);

/**
 * @generated from message google.v1.Label
 */
export type Label = Message<"google.v1.Label"> & {
  /**
   * Index into string table
   *
   * @generated from field: int64 key = 1;
   */
  key: bigint;

  /**
   * At most one of the following must be present
   *
   * Index into string table
   *
   * @generated from field: int64 str = 2;
   */
  str: bigint;

  /**
   * @generated from field: int64 num = 3;
   */
  num: bigint;

  /**
   * Should only be present when num is present.
   * Specifies the units of num.
   * Use arbitrary string (for example, "requests") as a custom count unit.
   * If no unit is specified, consumer may apply heuristic to deduce the unit.
   * Consumers may also  interpret units like "bytes" and "kilobytes" as memory
   * units and units like "seconds" and "nanoseconds" as time units,
   * and apply appropriate unit conversions to these.
   *
   * Index into string table
   *
   * @generated from field: int64 num_unit = 4;
   */
  numUnit: bigint;
};

/**
 * Describes the message google.v1.Label.
 * Use `create(LabelSchema)` to create a new message.
 */
export const LabelSchema: GenMessage<Label> = /*@__PURE__*/
  messageDesc(file_google_v1_profile, 3);

/**
 * @generated from message google.v1.Mapping
 */
export type Mapping = Message<"google.v1.Mapping"> & {
  /**
   * Unique nonzero id for the mapping.
   *
   * @generated from field: uint64 id = 1;
   */
  id: bigint;

  /**
   * Address at which the binary (or DLL) is loaded into memory.
   *
   * @generated from field: uint64 memory_start = 2;
   */
  memoryStart: bigint;

  /**
   * The limit of the address range occupied by this mapping.
   *
   * @generated from field: uint64 memory_limit = 3;
   */
  memoryLimit: bigint;

  /**
   * Offset in the binary that corresponds to the first mapped address.
   *
   * @generated from field: uint64 file_offset = 4;
   */
  fileOffset: bigint;

  /**
   * The object this entry is loaded from.  This can be a filename on
   * disk for the main binary and shared libraries, or virtual
   * abstractions like "[vdso]".
   *
   * Index into string table
   *
   * @generated from field: int64 filename = 5;
   */
  filename: bigint;

  /**
   * A string that uniquely identifies a particular program version
   * with high probability. E.g., for binaries generated by GNU tools,
   * it could be the contents of the .note.gnu.build-id field.
   *
   * Index into string table
   *
   * @generated from field: int64 build_id = 6;
   */
  buildId: bigint;

  /**
   * The following fields indicate the resolution of symbolic info.
   *
   * @generated from field: bool has_functions = 7;
   */
  hasFunctions: boolean;

  /**
   * @generated from field: bool has_filenames = 8;
   */
  hasFilenames: boolean;

  /**
   * @generated from field: bool has_line_numbers = 9;
   */
  hasLineNumbers: boolean;

  /**
   * @generated from field: bool has_inline_frames = 10;
   */
  hasInlineFrames: boolean;
};

/**
 * Describes the message google.v1.Mapping.
 * Use `create(MappingSchema)` to create a new message.
 */
export const MappingSchema: GenMessage<Mapping> = /*@__PURE__*/
  messageDesc(file_google_v1_profile, 4);

/**
 * Describes function and line table debug information.
 *
 * @generated from message google.v1.Location
 */
export type Location = Message<"google.v1.Location"> & {
  /**
   * Unique nonzero id for the location.  A profile could use
   * instruction addresses or any integer sequence as ids.
   *
   * @generated from field: uint64 id = 1;
   */
  id: bigint;

  /**
   * The id of the corresponding profile.Mapping for this location.
   * It can be unset if the mapping is unknown or not applicable for
   * this profile type.
   *
   * @generated from field: uint64 mapping_id = 2;
   */
  mappingId: bigint;

  /**
   * The instruction address for this location, if available.  It
   * should be within [Mapping.memory_start...Mapping.memory_limit]
   * for the corresponding mapping. A non-leaf address may be in the
   * middle of a call instruction. It is up to display tools to find
   * the beginning of the instruction if necessary.
   *
   * @generated from field: uint64 address = 3;
   */
  address: bigint;

  /**
   * Multiple line indicates this location has inlined functions,
   * where the last entry represents the caller into which the
   * preceding entries were inlined.
   *
   * E.g., if memcpy() is inlined into printf:
   *    line[0].function_name == "memcpy"
   *    line[1].function_name == "printf"
   *
   * @generated from field: repeated google.v1.Line line = 4;
   */
  line: Line[];

  /**
   * Provides an indication that multiple symbols map to this location's
   * address, for example due to identical code folding by the linker. In that
   * case the line information above represents one of the multiple
   * symbols. This field must be recomputed when the symbolization state of the
   * profile changes.
   *
   * @generated from field: bool is_folded = 5;
   */
  isFolded: boolean;
};

/**
 * Describes the message google.v1.Location.
 * Use `create(LocationSchema)` to create a new message.
 */
export const LocationSchema: GenMessage<Location> = /*@__PURE__*/
  messageDesc(file_google_v1_profile, 5);

/**
 * @generated from message google.v1.Line
 */
export type Line = Message<"google.v1.Line"> & {
  /**
   * The id of the corresponding profile.Function for this line.
   *
   * @generated from field: uint64 function_id = 1;
   */
  functionId: bigint;

  /**
   * Line number in source code.
   *
   * @generated from field: int64 line = 2;
   */
  line: bigint;
};

/**
 * Describes the message google.v1.Line.
 * Use `create(LineSchema)` to create a new message.
 */
export const LineSchema: GenMessage<Line> = /*@__PURE__*/
  messageDesc(file_google_v1_profile, 6);

/**
 * @generated from message google.v1.Function
 */
export type Function = Message<"google.v1.Function"> & {
  /**
   * Unique nonzero id for the function.
   *
   * @generated from field: uint64 id = 1;
   */
  id: bigint;

  /**
   * Name of the function, in human-readable form if available.
   *
   * Index into string table
   *
   * @generated from field: int64 name = 2;
   */
  name: bigint;

  /**
   * Name of the function, as identified by the system.
   * For instance, it can be a C++ mangled name.
   *
   * Index into string table
   *
   * @generated from field: int64 system_name = 3;
   */
  systemName: bigint;

  /**
   * Source file containing the function.
   *
   * Index into string table
   *
   * @generated from field: int64 filename = 4;
   */
  filename: bigint;

  /**
   * Line number in source file.
   *
   * @generated from field: int64 start_line = 5;
   */
  startLine: bigint;
};

/**
 * Describes the message google.v1.Function.
 * Use `create(FunctionSchema)` to create a new message.
 */
export const FunctionSchema: GenMessage<Function> = /*@__PURE__*/
  messageDesc(file_google_v1_profile, 7);

